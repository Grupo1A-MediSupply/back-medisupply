name: ğŸš€ Deploy to AWS ECS v3

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECS_SERVICE: medisupply-service
  ECS_CLUSTER: medisupply-cluster
  ECS_TASK_DEFINITION: medisupply-task-definition
  CONTAINER_NAME: medisupply-container

jobs:
  # Job para tests y build
  test-and-build:
    name: ğŸ§ª Test & Build
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: ğŸ Configurar Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: 'apiMS/microservices/requirements.txt'
    
    - name: ğŸ“¦ Instalar dependencias
      run: |
        cd apiMS/microservices
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-test.txt
    
    - name: ğŸ§ª Ejecutar tests - Auth Service
      run: |
        cd apiMS/microservices
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ” Auth Service - Tests Unitarios"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        export PYTHONPATH=$(pwd)
        pytest auth-service/tests/unit/test_value_objects.py auth-service/tests/unit/test_entities.py -v --tb=short
    
    - name: ğŸ§ª Ejecutar tests - Product Service
      run: |
        cd apiMS/microservices
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“¦ Product Service - Tests Unitarios"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        export PYTHONPATH=$(pwd)
        pytest product-service/tests/unit/ -v --tb=short

  deploy-infrastructure:
    name: ğŸ—ï¸ Deploy Infrastructure with Terraform
    runs-on: ubuntu-latest
    needs: test-and-build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/pipeline'
    
    steps:
    - name: ğŸ“¥ Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: ğŸ” Configurar AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ğŸ“‹ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
    
    - name: ğŸ” Terraform Format Check
      run: terraform fmt -check -recursive .
      working-directory: terraform/
    
    - name: ğŸ” Terraform Init
      run: terraform init
      working-directory: terraform/
    
    - name: ğŸ” Terraform Validate
      run: terraform validate
      working-directory: terraform/
    
    - name: ğŸ” Verificar estado de Terraform
      run: |
        echo "ğŸ” Verificando estado de Terraform..."
        terraform workspace list || echo "No hay workspaces"
        terraform state list || echo "Estado vacÃ­o o no inicializado"
        echo "âœ… VerificaciÃ³n completada"
      working-directory: terraform/
    
    - name: ğŸ“Š Terraform Plan
      run: |
        echo "ğŸ“Š Ejecutando Terraform Plan..."
        set -e  # Salir en caso de error
        terraform plan -out=tfplan
        echo "âœ… Terraform Plan completado exitosamente"
        
        # Mostrar resumen del plan
        echo "ğŸ“‹ Resumen del Plan:"
        terraform show -no-color tfplan | grep -E "(Plan:|No changes|to add|to change|to destroy)" || echo "No se pudo obtener resumen del plan"
      working-directory: terraform/
    
    - name: ğŸ”„ Importar recursos existentes (si es necesario)
      run: |
        echo "ğŸ”„ Importando recursos existentes..."
        
        # Importar ECR Repositories
        echo "ğŸ“¦ Importando ECR Repositories..."
        terraform import aws_ecr_repository.auth_service medisupply-auth-service 2>/dev/null || echo "ECR auth-service no necesita importaciÃ³n"
        terraform import aws_ecr_repository.product_service medisupply-product-service 2>/dev/null || echo "ECR product-service no necesita importaciÃ³n"
        
        # Importar IAM Roles
        echo "ğŸ” Importando IAM Roles..."
        terraform import aws_iam_role.ecs_task_execution_role medisupply-ecs-task-execution-role 2>/dev/null || echo "IAM Role ecs_task_execution_role no necesita importaciÃ³n"
        terraform import aws_iam_role.ecs_task_role medisupply-ecs-task-role 2>/dev/null || echo "IAM Role ecs_task_role no necesita importaciÃ³n"
        
        # Importar CloudWatch Log Group
        echo "ğŸ“Š Importando CloudWatch Log Group..."
        terraform import aws_cloudwatch_log_group.main /ecs/medisupply 2>/dev/null || echo "CloudWatch Log Group no necesita importaciÃ³n"
        
        # Importar Load Balancer
        echo "âš–ï¸ Importando Load Balancer..."
        ALB_ARN=$(aws elbv2 describe-load-balancers --names medisupply-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
        if [ -n "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
          terraform import aws_lb.main $ALB_ARN 2>/dev/null || echo "ALB no necesita importaciÃ³n"
        fi
        
        # Importar Target Group
        echo "ğŸ¯ Importando Target Group..."
        TG_ARN=$(aws elbv2 describe-target-groups --names medisupply-tg --query 'TargetGroups[0].TargetGroupArn' --output text 2>/dev/null || echo "")
        if [ -n "$TG_ARN" ] && [ "$TG_ARN" != "None" ]; then
          terraform import aws_lb_target_group.main $TG_ARN 2>/dev/null || echo "Target Group no necesita importaciÃ³n"
        fi
        
        # Importar Route Table Associations
        echo "ğŸ›£ï¸ Importando Route Table Associations..."
        # Buscar la Route Table que tiene asociaciones con las subnets pÃºblicas
        PUBLIC_RT_ID=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=vpc-05119ba31240eb9bd" --query 'RouteTables[?Associations[?SubnetId==`subnet-0adf58bad0bee883a` || SubnetId==`subnet-0eb32061dde9cae3f`]].RouteTableId | [0]' --output text 2>/dev/null || echo "")
        if [ -n "$PUBLIC_RT_ID" ] && [ "$PUBLIC_RT_ID" != "None" ]; then
          echo "Route Table encontrada: $PUBLIC_RT_ID"
          terraform import "aws_route_table_association.public[0]" "subnet-0adf58bad0bee883a/$PUBLIC_RT_ID" 2>/dev/null || echo "AsociaciÃ³n 0 no necesita importaciÃ³n"
          terraform import "aws_route_table_association.public[1]" "subnet-0eb32061dde9cae3f/$PUBLIC_RT_ID" 2>/dev/null || echo "AsociaciÃ³n 1 no necesita importaciÃ³n"
        else
          echo "âš ï¸ No se encontrÃ³ Route Table con asociaciones a subnets pÃºblicas"
        fi
        
        # Importar Security Groups
        echo "ğŸ”’ Importando Security Groups..."
        ALB_SG_ID=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=vpc-05119ba31240eb9bd" "Name=group-name,Values=medisupply-alb-sg" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        if [ -n "$ALB_SG_ID" ] && [ "$ALB_SG_ID" != "None" ]; then
          terraform import aws_security_group.alb $ALB_SG_ID 2>/dev/null || echo "ALB Security Group no necesita importaciÃ³n"
        fi
        
        ECS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=vpc-id,Values=vpc-05119ba31240eb9bd" "Name=group-name,Values=medisupply-ecs-tasks-sg" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        if [ -n "$ECS_SG_ID" ] && [ "$ECS_SG_ID" != "None" ]; then
          terraform import aws_security_group.ecs_tasks $ECS_SG_ID 2>/dev/null || echo "ECS Security Group no necesita importaciÃ³n"
        fi
        
        # Importar ECS Service
        echo "ğŸš€ Importando ECS Service..."
        ECS_SERVICE_ARN=$(aws ecs list-services --cluster medisupply-cluster --query 'serviceArns[0]' --output text 2>/dev/null || echo "")
        if [ -n "$ECS_SERVICE_ARN" ] && [ "$ECS_SERVICE_ARN" != "None" ]; then
          # Extraer el nombre del servicio del ARN
          ECS_SERVICE_NAME=$(echo $ECS_SERVICE_ARN | cut -d'/' -f3)
          terraform import aws_ecs_service.main medisupply-cluster/$ECS_SERVICE_NAME 2>/dev/null || echo "ECS Service no necesita importaciÃ³n"
        fi
        
        echo "âœ… ImportaciÃ³n completada"
      working-directory: terraform/
      continue-on-error: true
    
    - name: ğŸš€ Terraform Apply
      run: |
        echo "ğŸš€ Aplicando cambios de Terraform..."
        echo "ğŸ“‹ Plan a aplicar:"
        terraform show -no-color tfplan | head -20
        echo "..."
        
        # Aplicar el plan
        if terraform apply -auto-approve tfplan; then
          echo "âœ… Terraform apply exitoso"
        else
          echo "âš ï¸ Apply fallÃ³, intentando con -replace para recursos problemÃ¡ticos..."
          # Si falla, intentar con replace para recursos que podrÃ­an estar duplicados
          if terraform apply -auto-approve -replace=aws_lb.main -replace=aws_lb_target_group.main; then
            echo "âœ… Terraform apply con replace exitoso"
          else
            echo "âŒ Terraform apply fallÃ³ completamente"
            exit 1
          fi
        fi
      working-directory: terraform/
    
    - name: ğŸ“Š Mostrar outputs de Terraform
      run: |
        echo "ğŸ“‹ Terraform Outputs:"
        echo "===================="
        terraform output || echo "No outputs available yet"
      working-directory: terraform/
    
    - name: â³ Esperar a que el Load Balancer se inicialice
      run: |
        echo "â³ Esperando a que el Load Balancer se inicialice..."
        # Esperar hasta 5 minutos para que el Load Balancer estÃ© disponible
        for i in {1..30}; do
          ALB_DNS=$(aws elbv2 describe-load-balancers --names medisupply-alb --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ] && [ "$ALB_DNS" != "null" ]; then
            echo "âœ… Load Balancer DNS disponible: $ALB_DNS"
            break
          else
            echo "â³ Esperando... (intento $i/30)"
            sleep 10
          fi
        done
      working-directory: terraform/
    
    - name: ğŸ” Verificar estado del Load Balancer
      run: |
        echo "ğŸ” Verificando estado del Load Balancer..."
        # Verificar si el Load Balancer existe
        ALB_ARN=$(aws elbv2 describe-load-balancers --names medisupply-alb --query 'LoadBalancers[0].LoadBalancerArn' --output text 2>/dev/null || echo "")
        if [ -n "$ALB_ARN" ] && [ "$ALB_ARN" != "None" ]; then
          echo "âœ… Load Balancer encontrado: $ALB_ARN"
          # Obtener el DNS name
          ALB_DNS=$(aws elbv2 describe-load-balancers --names medisupply-alb --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            echo "âœ… DNS Name: $ALB_DNS"
          else
            echo "âš ï¸ DNS Name no disponible aÃºn"
          fi
          # Verificar el estado
          ALB_STATE=$(aws elbv2 describe-load-balancers --names medisupply-alb --query 'LoadBalancers[0].State.Code' --output text 2>/dev/null || echo "")
          echo "ğŸ“Š Estado del Load Balancer: $ALB_STATE"
        else
          echo "âŒ Load Balancer no encontrado"
        fi
      working-directory: terraform/
    
    - name: ğŸ“ Output ECS Service URL
      run: |
        echo "ECS Service deployed successfully!"
        # Verificar si el output existe y no es null
        ECS_URL=$(terraform output -json | jq -r '.ecs_service_url.value // empty' 2>/dev/null || echo "")
        if [ -n "$ECS_URL" ] && [ "$ECS_URL" != "null" ]; then
          echo "ECS Service URL: $ECS_URL"
          echo "ecs_service_url=$ECS_URL" >> $GITHUB_OUTPUT
        else
          echo "Warning: ECS service URL not available yet (Load Balancer may still be initializing)"
          # Intentar obtener el DNS name directamente del Load Balancer
          ALB_DNS=$(aws elbv2 describe-load-balancers --names medisupply-alb --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
          if [ -n "$ALB_DNS" ] && [ "$ALB_DNS" != "None" ]; then
            ECS_URL="http://$ALB_DNS"
            echo "ECS Service URL (from AWS): $ECS_URL"
            echo "ecs_service_url=$ECS_URL" >> $GITHUB_OUTPUT
          else
            echo "ecs_service_url=not-available" >> $GITHUB_OUTPUT
          fi
        fi
      working-directory: terraform/

  build-and-push:
    name: ğŸ³ Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/pipeline'
    
    strategy:
      matrix:
        service: [auth-service, product-service]
    
    steps:
    - name: ğŸ“¥ Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: ğŸ” Configurar AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ğŸ”‘ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: ğŸ—ï¸ Build, tag, and push image to Amazon ECR
      env:
        ECR_REPOSITORY: medisupply-${{ matrix.service }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                     -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
                     -f apiMS/microservices/${{ matrix.service }}/Dockerfile \
                     apiMS/microservices/
        
        # Push image
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Save image URI for deployment
        echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # Job para actualizar servicio ECS
  update-ecs-service:
    name: ğŸ”„ Update ECS Service
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/feature/pipeline'
    
    steps:
    - name: ğŸ” Configurar AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: ğŸ”„ Update ECS service
      run: |
        # Force new deployment
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --force-new-deployment
        
        # Wait for deployment to complete
        aws ecs wait services-stable \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE
        
        echo "âœ… ECS service updated successfully!"
    
    - name: ğŸ“Š Verificar salud del servicio
      run: |
        echo "ğŸ” Checking service health..."
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE \
          --query 'services[0].deployments[0].{status:status,runningCount:runningCount,desiredCount:desiredCount}'
