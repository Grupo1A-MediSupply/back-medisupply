name: üöÄ Deploy to GCP Cloud Run

on:
  push:
    branches:
      - mains
    
  pull_request:
    branches:
      - mains
    
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - devs
          

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: us-central1
  ARTIFACT_REGISTRY: ${{ secrets.GCP_PROJECT_ID }}-docker-repo

jobs:
  # ============================================================================
  # Build and Push Docker Images
  # ============================================================================
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
    
    - name: üîê Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: üê≥ Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: üîß Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet
    
    - name: üîç Verify Artifact Registry exists
      run: |
        # Crear repositorio si no existe (Terraform lo crear√°, pero por si acaso)
        gcloud artifacts repositories describe ${{ env.ARTIFACT_REGISTRY }} \
          --location=${{ env.GCP_REGION }} \
          --format="value(name)" || \
        gcloud artifacts repositories create ${{ env.ARTIFACT_REGISTRY }} \
          --repository-format=docker \
          --location=${{ env.GCP_REGION }} \
          --description="Docker repository for MediSupply microservices" || true
    
    - name: üì¶ Build and Push Auth Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f auth-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:latest
    
    - name: üì¶ Build and Push Product Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f product-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:latest
    
    - name: üì¶ Build and Push Order Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f order-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:latest
    
    - name: üì¶ Build and Push Logistics Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f logistics-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:latest
    
    - name: üì¶ Build and Push Notifications Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f notifications-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:latest
    
    - name: üì¶ Build and Push Inventory Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f inventory-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/inventory-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/inventory-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/inventory-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/inventory-service:latest
    
    - name: üì¶ Build and Push Reports Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f reports-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/reports-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/reports-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/reports-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/reports-service:latest
    
    - name: üì¶ Build and Push API Gateway
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f api-gateway/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/api-gateway:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/api-gateway:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/api-gateway:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/api-gateway:latest

  # ============================================================================
  # Deploy with Terraform
  # ============================================================================
  deploy:
    name: Deploy Infrastructure with Terraform
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
    
    # Nota: El Service Account en GCP_SA_KEY necesita los siguientes roles:
    # - roles/run.admin, roles/artifactregistry.admin, roles/secretmanager.admin
    # - roles/iam.serviceAccountUser, roles/cloudsql.admin, roles/iam.securityAdmin
    # Si ves errores 403, ejecuta: ./apiMS/microservices/terraform/update-permissions.sh
    - name: üîê Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: üê≥ Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: üì¶ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.6.0"
    
    - name: üîç Verificar recursos existentes y limpiar
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
      run: |
        echo "üîç Verificando recursos Cloud Run existentes..."
        
        # Servicios a verificar
        SERVICES=("auth-service" "product-service" "order-service" "logistics-service" "notifications-service" "inventory-service" "reports-service" "api-gateway")
        FOUND_SERVICES=()
        
        for service in "${SERVICES[@]}"; do
          if gcloud run services describe "$service" \
            --region=${{ env.GCP_REGION }} \
            --format="value(name)" 2>/dev/null | grep -q "$service"; then
            echo "‚ö†Ô∏è  Servicio encontrado: $service"
            FOUND_SERVICES+=("$service")
          fi
        done
        
        if [ ${#FOUND_SERVICES[@]} -gt 0 ]; then
          echo "üìã Servicios encontrados (${#FOUND_SERVICES[@]}): ${FOUND_SERVICES[*]}"
          echo "üóëÔ∏è  Eliminando servicios existentes antes del despliegue..."
          
          for service in "${FOUND_SERVICES[@]}"; do
            echo "   Eliminando $service..."
            gcloud run services delete "$service" \
              --region=${{ env.GCP_REGION }} \
              --quiet || echo "   ‚ö†Ô∏è  No se pudo eliminar $service (puede que ya no exista)"
          done
          
          echo "‚è≥ Esperando 10 segundos para que se completen las eliminaciones..."
          sleep 10
          echo "‚úÖ Limpieza completada"
        else
          echo "‚úÖ No se encontraron servicios existentes para limpiar"
        fi
    
    - name: üîß Terraform Init
      working-directory: apiMS/microservices/terraform
      run: |
        terraform init
    
    - name: üì• Importar recursos existentes (si existen)
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
        TF_VAR_enable_cloud_sql: ${{ secrets.ENABLE_CLOUD_SQL || vars.ENABLE_CLOUD_SQL || 'true' }}
      run: |
        echo "üîç Verificando y importando recursos existentes..."
        
        PROJECT_ID="${{ secrets.GCP_PROJECT_ID }}"
        REGION="us-central1"
        REPO_ID="${PROJECT_ID}-docker-repo"
        SECRET_ID="auth-service-secret-key"
        
        # Importar Artifact Registry si existe
        if gcloud artifacts repositories describe "$REPO_ID" --location="$REGION" --project="$PROJECT_ID" &>/dev/null; then
          echo "üì¶ Importando Artifact Registry: $REPO_ID"
          terraform import \
            "google_artifact_registry_repository.docker_repo" \
            "projects/$PROJECT_ID/locations/$REGION/repositories/$REPO_ID" 2>/dev/null || \
            echo "   ‚úÖ Ya importado o no necesario"
        else
          echo "   ‚ÑπÔ∏è  Artifact Registry no existe, se crear√° autom√°ticamente"
        fi
        
        # Importar Secret Manager (auth-service-secret-key) si existe
        if gcloud secrets describe "$SECRET_ID" --project="$PROJECT_ID" &>/dev/null; then
          echo "üîê Importando Secret Manager: $SECRET_ID"
          terraform import \
            "google_secret_manager_secret.secret_key" \
            "projects/$PROJECT_ID/secrets/$SECRET_ID" 2>/dev/null || \
            echo "   ‚úÖ Ya importado o no necesario"
        else
          echo "   ‚ÑπÔ∏è  Secret Manager ($SECRET_ID) no existe, se crear√° autom√°ticamente"
        fi
        
        # Importar secretos de base de datos y Cloud SQL si existen y Cloud SQL est√° habilitado
        if [ "${TF_VAR_enable_cloud_sql:-true}" != "false" ]; then
          echo "üóÑÔ∏è  Verificando instancia de Cloud SQL..."
          
          # Nombre de la instancia de Cloud SQL
          INSTANCE_NAME="${PROJECT_ID}-postgres-instance"
          
          # Verificar e importar instancia de Cloud SQL si existe
          if gcloud sql instances describe "$INSTANCE_NAME" --project="$PROJECT_ID" &>/dev/null; then
            echo "üóÑÔ∏è  Importando instancia de Cloud SQL: $INSTANCE_NAME"
            terraform import \
              "google_sql_database_instance.postgres[0]" \
              "${PROJECT_ID}/${INSTANCE_NAME}" 2>/dev/null || \
              echo "   ‚úÖ Ya importado o no necesario"
            
            # Importar bases de datos si existen
            echo "üìä Verificando bases de datos..."
            DATABASES=("auth_service" "product_service" "order_service" "logistics_service" "notifications_service" "inventory_service" "reports_service")
            for DB_NAME in "${DATABASES[@]}"; do
              if gcloud sql databases describe "$DB_NAME" --instance="$INSTANCE_NAME" --project="$PROJECT_ID" &>/dev/null; then
                echo "   üìä Importando base de datos: $DB_NAME"
                case "$DB_NAME" in
                  "auth_service")
                    terraform import "google_sql_database.auth_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                  "product_service")
                    terraform import "google_sql_database.product_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                  "order_service")
                    terraform import "google_sql_database.order_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                  "logistics_service")
                    terraform import "google_sql_database.logistics_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                  "notifications_service")
                    terraform import "google_sql_database.notifications_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                  "inventory_service")
                    terraform import "google_sql_database.inventory_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                  "reports_service")
                    terraform import "google_sql_database.reports_db[0]" "${PROJECT_ID}/${INSTANCE_NAME}/${DB_NAME}" 2>/dev/null || echo "      ‚úÖ Ya importado"
                    ;;
                esac
              else
                echo "   ‚ÑπÔ∏è  Base de datos ($DB_NAME) no existe, se crear√° autom√°ticamente"
              fi
            done
          else
            echo "   ‚ÑπÔ∏è  Instancia de Cloud SQL ($INSTANCE_NAME) no existe, se crear√° autom√°ticamente"
          fi
          
          echo "üîê Verificando secretos de base de datos..."
          
          # Lista de secretos de base de datos
          declare -A DB_SECRETS=(
            ["auth-service-db-password"]="google_secret_manager_secret.auth_db_password[0]"
            ["product-service-db-password"]="google_secret_manager_secret.product_db_password[0]"
            ["order-service-db-password"]="google_secret_manager_secret.order_db_password[0]"
            ["logistics-service-db-password"]="google_secret_manager_secret.logistics_db_password[0]"
            ["notifications-service-db-password"]="google_secret_manager_secret.notifications_db_password[0]"
            ["inventory-service-db-password"]="google_secret_manager_secret.inventory_db_password[0]"
            ["reports-service-db-password"]="google_secret_manager_secret.reports_db_password[0]"
          )
          
          for DB_SECRET in "${!DB_SECRETS[@]}"; do
            TERRAFORM_RESOURCE="${DB_SECRETS[$DB_SECRET]}"
            
            if gcloud secrets describe "$DB_SECRET" --project="$PROJECT_ID" &>/dev/null; then
              echo "üîê Importando Secret Manager DB: $DB_SECRET"
              terraform import \
                "$TERRAFORM_RESOURCE" \
                "projects/$PROJECT_ID/secrets/$DB_SECRET" 2>/dev/null || \
                echo "   ‚úÖ Ya importado o no necesario"
            else
              echo "   ‚ÑπÔ∏è  Secret DB ($DB_SECRET) no existe, se crear√° autom√°ticamente"
            fi
          done
        fi
        
        echo "‚úÖ Importaci√≥n completada"
    
    - name: üîç Debug Informaci√≥n del Workflow
      run: |
        echo "üîç Informaci√≥n del workflow:"
        echo "  Evento: ${{ github.event_name }}"
        echo "  Rama: ${{ github.ref }}"
        echo "  SHA: ${{ github.sha }}"
        echo "  Actor: ${{ github.actor }}"
        echo ""
        echo "üîç Condiciones para terraform apply:"
        echo "  - github.event_name == 'push': ${{ github.event_name == 'push' }}"
        echo "  - github.event_name == 'workflow_dispatch': ${{ github.event_name == 'workflow_dispatch' }}"
        echo "  - Condici√≥n completa: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}"
    
    - name: ‚úÖ Terraform Validate
      working-directory: apiMS/microservices/terraform
      run: |
        terraform validate
    
    - name: üìã Terraform Plan
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
        TF_VAR_enable_cloud_sql: ${{ secrets.ENABLE_CLOUD_SQL || vars.ENABLE_CLOUD_SQL || 'true' }}
      run: |
        set -e  # Salir si cualquier comando falla (excepto donde se desactive expl√≠citamente)
        echo "üìã Generando plan de Terraform..."
        echo "üîç Evento que dispar√≥ el workflow: ${{ github.event_name }}"
        echo "üîç Rama: ${{ github.ref }}"
        
        # Generar el plan
        # Redirigir stderr a stdout para capturar todos los mensajes
        if terraform plan -out=tfplan 2>&1 | tee /tmp/terraform-plan.log; then
          echo "‚úÖ Plan generado exitosamente"
          
          # Verificar que el archivo del plan existe
          if [ -f "tfplan" ]; then
            echo "‚úÖ Archivo tfplan creado correctamente"
            PLAN_SIZE=$(ls -lh tfplan | awk '{print $5}')
            echo "üì¶ Tama√±o del plan: $PLAN_SIZE"
          else
            echo "‚ùå ERROR: El archivo tfplan no se cre√≥"
            exit 1
          fi
          
          # Mostrar resumen del plan
          echo ""
          echo "üìä Resumen del plan:"
          # Guardar el JSON en una variable temporal para evitar problemas de pipe
          set +e
          PLAN_JSON=$(terraform show -json tfplan 2>&1)
          if [ $? -eq 0 ] && [ -n "$PLAN_JSON" ]; then
            echo "$PLAN_JSON" | jq -r '
              .resource_changes[] | 
              select(.change.actions != null and (.change.actions | length > 0)) |
              "  \(.change.actions[0]) \(.address)"
            ' 2>/dev/null || echo "  No hay cambios planificados"
          else
            echo "  ‚ö†Ô∏è  No se pudo obtener el resumen del plan"
          fi
          set -e
        else
          echo "‚ùå ERROR: Fall√≥ la generaci√≥n del plan"
          echo "üîç Mostrando √∫ltimos logs de terraform..."
          if [ -f /tmp/terraform-plan.log ]; then
            tail -50 /tmp/terraform-plan.log
          else
            echo "‚ö†Ô∏è  No se encontraron logs guardados"
          fi
          exit 1
        fi
    
    - name: üöÄ Terraform Apply
      if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
        TF_VAR_enable_cloud_sql: ${{ secrets.ENABLE_CLOUD_SQL || vars.ENABLE_CLOUD_SQL || 'true' }}
      run: |
        set -e  # Salir si cualquier comando falla
        echo "üöÄ Iniciando Terraform Apply..."
        echo "üîç Evento: ${{ github.event_name }}"
        echo "üîç Rama: ${{ github.ref }}"
        
        # Verificar que el plan existe
        if [ ! -f "tfplan" ]; then
          echo "‚ùå ERROR: El archivo tfplan no existe"
          echo "üí° Esto puede ocurrir si el paso 'Terraform Plan' fall√≥ o no se ejecut√≥"
          exit 1
        fi
        
        echo "‚úÖ Archivo tfplan encontrado"
        PLAN_SIZE=$(ls -lh tfplan | awk '{print $5}')
        echo "üì¶ Tama√±o del plan: $PLAN_SIZE"
        
        # Mostrar un resumen del plan antes de aplicar
        echo ""
        echo "üìã Resumen del plan a aplicar:"
        set +e
        terraform show -no-color tfplan 2>&1 | head -30 || echo "‚ö†Ô∏è  No se pudo mostrar el resumen"
        set -e
        echo "..."
        
        # Aplicar el plan
        echo ""
        echo "üöÄ Aplicando cambios..."
        if terraform apply -auto-approve tfplan; then
          echo "‚úÖ Terraform apply completado exitosamente"
        else
          echo "‚ùå ERROR: Terraform apply fall√≥"
          echo "üîç Mostrando √∫ltimos logs..."
          terraform apply -auto-approve tfplan 2>&1 | tail -50
          exit 1
        fi
    
    - name: üìä Get Service URLs
      if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
      working-directory: apiMS/microservices/terraform
      run: |
        set +e  # No fallar si alg√∫n output no existe
        echo "üîó URLs de Servicios:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Funci√≥n helper para obtener URLs de forma segura
        get_url() {
          local output_name=$1
          # Capturar solo stdout, redirigir stderr a /dev/null
          # Filtrar mensajes de error de GitHub Actions
          local url=$(terraform output -raw "$output_name" 2>/dev/null | grep -v "^::error::" | grep -v "^::warning::" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # Verificar que la URL es v√°lida (no est√° vac√≠a, no es null, no es un mensaje de error)
          if [ $? -eq 0 ] && [ -n "$url" ] && [ "$url" != "null" ] && [[ ! "$url" =~ ^:: ]]; then
            echo "$url"
          else
            echo "N/A"
          fi
        }
        
        # Obtener URLs de todos los servicios
        API_GATEWAY_URL=$(get_url "api_gateway_url")
        AUTH_URL=$(get_url "auth_service_url")
        PRODUCT_URL=$(get_url "product_service_url")
        ORDER_URL=$(get_url "order_service_url")
        LOGISTICS_URL=$(get_url "logistics_service_url")
        NOTIFICATIONS_URL=$(get_url "notifications_service_url")
        INVENTORY_URL=$(get_url "inventory_service_url")
        REPORTS_URL=$(get_url "reports_service_url")
        
        # Escribir al summary
        echo "API Gateway: $API_GATEWAY_URL" >> $GITHUB_STEP_SUMMARY
        echo "Auth Service: $AUTH_URL" >> $GITHUB_STEP_SUMMARY
        echo "Product Service: $PRODUCT_URL" >> $GITHUB_STEP_SUMMARY
        echo "Order Service: $ORDER_URL" >> $GITHUB_STEP_SUMMARY
        echo "Logistics Service: $LOGISTICS_URL" >> $GITHUB_STEP_SUMMARY
        echo "Notifications Service: $NOTIFICATIONS_URL" >> $GITHUB_STEP_SUMMARY
        echo "Inventory Service: $INVENTORY_URL" >> $GITHUB_STEP_SUMMARY
        echo "Reports Service: $REPORTS_URL" >> $GITHUB_STEP_SUMMARY
        
        # Tambi√©n mostrar en los logs
        echo ""
        echo "üìä URLs de Servicios Desplegados:"
        echo "=================================="
        echo "API Gateway: $API_GATEWAY_URL"
        echo "Auth Service: $AUTH_URL"
        echo "Product Service: $PRODUCT_URL"
        echo "Order Service: $ORDER_URL"
        echo "Logistics Service: $LOGISTICS_URL"
        echo "Notifications Service: $NOTIFICATIONS_URL"
        echo "Inventory Service: $INVENTORY_URL"
        echo "Reports Service: $REPORTS_URL"
        set -e

  # ============================================================================
  # Health Check
  # ============================================================================
  health-check:
    name: Health Check Services
    needs: deploy
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
    
    - name: üîê Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: üê≥ Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: üì¶ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.6.0"
    
    - name: üîß Terraform Init
      working-directory: apiMS/microservices/terraform
      run: terraform init
    
    - name: üè• Health Check Services
      working-directory: apiMS/microservices/terraform
      run: |
        API_GATEWAY_URL=$(terraform output -raw api_gateway_url 2>/dev/null || echo "")
        AUTH_URL=$(terraform output -raw auth_service_url)
        PRODUCT_URL=$(terraform output -raw product_service_url)
        ORDER_URL=$(terraform output -raw order_service_url)
        LOGISTICS_URL=$(terraform output -raw logistics_service_url)
        NOTIFICATIONS_URL=$(terraform output -raw notifications_service_url)
        INVENTORY_URL=$(terraform output -raw inventory_service_url 2>/dev/null || echo "")
        REPORTS_URL=$(terraform output -raw reports_service_url 2>/dev/null || echo "")
        
        echo "üîç Verificando salud de servicios..."
        echo ""
        echo "üìã URLs de los servicios:"
        [ -n "$API_GATEWAY_URL" ] && echo "   API Gateway: $API_GATEWAY_URL"
        echo "   Auth Service: $AUTH_URL"
        echo "   Product Service: $PRODUCT_URL"
        echo "   Order Service: $ORDER_URL"
        echo "   Logistics Service: $LOGISTICS_URL"
        echo "   Notifications Service: $NOTIFICATIONS_URL"
        [ -n "$INVENTORY_URL" ] && echo "   Inventory Service: $INVENTORY_URL"
        [ -n "$REPORTS_URL" ] && echo "   Reports Service: $REPORTS_URL"
        echo ""
        
        # Funci√≥n para verificar servicio con retry mejorado
        check_service() {
          local name=$1
          local url=$2
          local max_attempts=6  # Aumentado de 3 a 6 intentos
          local attempt=1
          local wait_time=10   # Aumentado de 5 a 10 segundos entre intentos
          
          while [ $attempt -le $max_attempts ]; do
            echo "   üîç Intento $attempt/$max_attempts para $name..."
            # Capturar respuesta y c√≥digo HTTP para debug
            response=$(curl -s -w "\nHTTP_CODE:%{http_code}\nTIME:%{time_total}" --max-time 15 "$url/health" 2>&1)
            http_code=$(echo "$response" | grep "HTTP_CODE" | cut -d: -f2 || echo "")
            
            if [ "$http_code" = "200" ]; then
              echo "‚úÖ $name OK (HTTP $http_code)"
              return 0
            else
              # Mostrar informaci√≥n de debug
              if [ -n "$http_code" ] && [ "$http_code" != "" ]; then
                echo "   ‚ö†Ô∏è  HTTP $http_code - Reintentando en ${wait_time}s..."
              else
                echo "   ‚ö†Ô∏è  No se pudo conectar - El servicio puede estar iniciando. Esperando ${wait_time}s..."
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                sleep $wait_time
              fi
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå $name FAILED despu√©s de $max_attempts intentos"
          # Intentar verificar el endpoint ra√≠z para m√°s informaci√≥n
          echo "   üîç Verificando endpoint ra√≠z para diagn√≥stico..."
          root_response=$(curl -s --max-time 5 "$url/" 2>&1 || echo "No response")
          if echo "$root_response" | grep -q "service"; then
            echo "   ‚ÑπÔ∏è  El servicio est√° respondiendo pero /health puede tener problemas"
          else
            echo "   ‚ö†Ô∏è  El servicio no est√° respondiendo en absoluto"
          fi
          return 1
        }
        
        # Contador de servicios fallidos
        failed_services=0
        
        [ -n "$API_GATEWAY_URL" ] && check_service "API Gateway" "$API_GATEWAY_URL" || failed_services=$((failed_services + 1))
        check_service "Auth Service" "$AUTH_URL" || failed_services=$((failed_services + 1))
        check_service "Product Service" "$PRODUCT_URL" || failed_services=$((failed_services + 1))
        check_service "Order Service" "$ORDER_URL" || failed_services=$((failed_services + 1))
        check_service "Logistics Service" "$LOGISTICS_URL" || failed_services=$((failed_services + 1))
        check_service "Notifications Service" "$NOTIFICATIONS_URL" || failed_services=$((failed_services + 1))
        [ -n "$INVENTORY_URL" ] && check_service "Inventory Service" "$INVENTORY_URL" || failed_services=$((failed_services + 1))
        [ -n "$REPORTS_URL" ] && check_service "Reports Service" "$REPORTS_URL" || failed_services=$((failed_services + 1))
        
        echo ""
        echo "üìä Resumen de Health Checks:"
        if [ $failed_services -eq 0 ]; then
          echo "‚úÖ Todos los servicios est√°n funcionando correctamente"
          exit 0
        else
          echo "‚ö†Ô∏è  $failed_services servicio(s) fallaron el health check"
          echo "üí° Los servicios pueden estar a√∫n inicializ√°ndose (Cloud Run escala a cero)"
          echo "üí° Verifica los logs en Cloud Run Console: https://console.cloud.google.com/run"
          echo "üí° Espera unos minutos y verifica manualmente las URLs"
          # No fallar el workflow si algunos servicios fallan (solo avisar)
          exit 0
        fi

