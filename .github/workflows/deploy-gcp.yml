name: üöÄ Deploy to GCP Cloud Run

on:
  push:
    branches:
      - '**'  # Cualquier rama
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: us-central1
  ARTIFACT_REGISTRY: ${{ secrets.GCP_PROJECT_ID }}-docker-repo

jobs:
  # ============================================================================
  # Build and Push Docker Images
  # ============================================================================
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
    
    - name: üîê Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: üê≥ Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: üîß Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet
    
    - name: üîç Verify Artifact Registry exists
      run: |
        # Crear repositorio si no existe (Terraform lo crear√°, pero por si acaso)
        gcloud artifacts repositories describe ${{ env.ARTIFACT_REGISTRY }} \
          --location=${{ env.GCP_REGION }} \
          --format="value(name)" || \
        gcloud artifacts repositories create ${{ env.ARTIFACT_REGISTRY }} \
          --repository-format=docker \
          --location=${{ env.GCP_REGION }} \
          --description="Docker repository for MediSupply microservices" || true
    
    - name: üì¶ Build and Push Auth Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f auth-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/auth-service:latest
    
    - name: üì¶ Build and Push Product Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f product-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/product-service:latest
    
    - name: üì¶ Build and Push Order Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f order-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/order-service:latest
    
    - name: üì¶ Build and Push Logistics Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f logistics-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/logistics-service:latest
    
    - name: üì¶ Build and Push Notifications Service
      working-directory: apiMS/microservices
      run: |
        docker build \
          --platform linux/amd64 \
          -f notifications-service/Dockerfile \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:${{ github.sha }} \
          -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:latest \
          .
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:${{ github.sha }}
        docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/notifications-service:latest

  # ============================================================================
  # Deploy with Terraform
  # ============================================================================
  deploy:
    name: Deploy Infrastructure with Terraform
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
    
    # Nota: El Service Account en GCP_SA_KEY necesita los siguientes roles:
    # - roles/run.admin, roles/artifactregistry.admin, roles/secretmanager.admin
    # - roles/iam.serviceAccountUser, roles/cloudsql.admin, roles/iam.securityAdmin
    # Si ves errores 403, ejecuta: ./apiMS/microservices/terraform/update-permissions.sh
    - name: üîê Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: üê≥ Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: üì¶ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.6.0"
    
    - name: üîç Verificar recursos existentes y limpiar
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
      run: |
        echo "üîç Verificando recursos Cloud Run existentes..."
        
        # Servicios a verificar
        SERVICES=("auth-service" "product-service" "order-service" "logistics-service" "notifications-service")
        FOUND_SERVICES=()
        
        for service in "${SERVICES[@]}"; do
          if gcloud run services describe "$service" \
            --region=${{ env.GCP_REGION }} \
            --format="value(name)" 2>/dev/null | grep -q "$service"; then
            echo "‚ö†Ô∏è  Servicio encontrado: $service"
            FOUND_SERVICES+=("$service")
          fi
        done
        
        if [ ${#FOUND_SERVICES[@]} -gt 0 ]; then
          echo "üìã Servicios encontrados (${#FOUND_SERVICES[@]}): ${FOUND_SERVICES[*]}"
          echo "üóëÔ∏è  Eliminando servicios existentes antes del despliegue..."
          
          for service in "${FOUND_SERVICES[@]}"; do
            echo "   Eliminando $service..."
            gcloud run services delete "$service" \
              --region=${{ env.GCP_REGION }} \
              --quiet || echo "   ‚ö†Ô∏è  No se pudo eliminar $service (puede que ya no exista)"
          done
          
          echo "‚è≥ Esperando 10 segundos para que se completen las eliminaciones..."
          sleep 10
          echo "‚úÖ Limpieza completada"
        else
          echo "‚úÖ No se encontraron servicios existentes para limpiar"
        fi
    
    - name: üîß Terraform Init
      working-directory: apiMS/microservices/terraform
      run: |
        terraform init
    
    - name: üì• Importar recursos existentes (si existen)
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
        TF_VAR_enable_cloud_sql: ${{ secrets.ENABLE_CLOUD_SQL || vars.ENABLE_CLOUD_SQL || 'true' }}
      run: |
        echo "üîç Verificando y importando recursos existentes..."
        
        PROJECT_ID="${{ secrets.GCP_PROJECT_ID }}"
        REGION="us-central1"
        REPO_ID="${PROJECT_ID}-docker-repo"
        SECRET_ID="auth-service-secret-key"
        
        # Importar Artifact Registry si existe
        if gcloud artifacts repositories describe "$REPO_ID" --location="$REGION" --project="$PROJECT_ID" &>/dev/null; then
          echo "üì¶ Importando Artifact Registry: $REPO_ID"
          terraform import \
            "google_artifact_registry_repository.docker_repo" \
            "projects/$PROJECT_ID/locations/$REGION/repositories/$REPO_ID" 2>/dev/null || \
            echo "   ‚úÖ Ya importado o no necesario"
        else
          echo "   ‚ÑπÔ∏è  Artifact Registry no existe, se crear√° autom√°ticamente"
        fi
        
        # Importar Secret Manager (auth-service-secret-key) si existe
        if gcloud secrets describe "$SECRET_ID" --project="$PROJECT_ID" &>/dev/null; then
          echo "üîê Importando Secret Manager: $SECRET_ID"
          terraform import \
            "google_secret_manager_secret.secret_key" \
            "projects/$PROJECT_ID/secrets/$SECRET_ID" 2>/dev/null || \
            echo "   ‚úÖ Ya importado o no necesario"
        else
          echo "   ‚ÑπÔ∏è  Secret Manager ($SECRET_ID) no existe, se crear√° autom√°ticamente"
        fi
        
        # Importar secretos de base de datos si existen y Cloud SQL est√° habilitado
        if [ "${TF_VAR_enable_cloud_sql:-true}" != "false" ]; then
          echo "üîê Verificando secretos de base de datos..."
          
          # Lista de secretos de base de datos
          declare -A DB_SECRETS=(
            ["auth-service-db-password"]="google_secret_manager_secret.auth_db_password[0]"
            ["product-service-db-password"]="google_secret_manager_secret.product_db_password[0]"
            ["order-service-db-password"]="google_secret_manager_secret.order_db_password[0]"
            ["logistics-service-db-password"]="google_secret_manager_secret.logistics_db_password[0]"
            ["notifications-service-db-password"]="google_secret_manager_secret.notifications_db_password[0]"
          )
          
          for DB_SECRET in "${!DB_SECRETS[@]}"; do
            TERRAFORM_RESOURCE="${DB_SECRETS[$DB_SECRET]}"
            
            if gcloud secrets describe "$DB_SECRET" --project="$PROJECT_ID" &>/dev/null; then
              echo "üîê Importando Secret Manager DB: $DB_SECRET"
              terraform import \
                "$TERRAFORM_RESOURCE" \
                "projects/$PROJECT_ID/secrets/$DB_SECRET" 2>/dev/null || \
                echo "   ‚úÖ Ya importado o no necesario"
            else
              echo "   ‚ÑπÔ∏è  Secret DB ($DB_SECRET) no existe, se crear√° autom√°ticamente"
            fi
          done
        fi
        
        echo "‚úÖ Importaci√≥n completada"
    
    - name: ‚úÖ Terraform Validate
      working-directory: apiMS/microservices/terraform
      run: |
        terraform validate
    
    - name: üìã Terraform Plan
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
        TF_VAR_enable_cloud_sql: ${{ secrets.ENABLE_CLOUD_SQL || vars.ENABLE_CLOUD_SQL || 'true' }}
      run: |
        echo "üìã Generando plan de Terraform..."
        terraform plan -out=tfplan
        
        # Mostrar resumen del plan
        echo ""
        echo "üìä Resumen del plan:"
        terraform show -json tfplan | jq -r '
          .resource_changes[] | 
          select(.change.actions != null and (.change.actions | length > 0)) |
          "  \(.change.actions[0]) \(.address)"
        ' || echo "  No hay cambios planificados"
    
    - name: üöÄ Terraform Apply
      if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
      working-directory: apiMS/microservices/terraform
      env:
        TF_VAR_project_id: ${{ secrets.GCP_PROJECT_ID }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
        TF_VAR_region: us-central1
        TF_VAR_enable_cloud_sql: ${{ secrets.ENABLE_CLOUD_SQL || vars.ENABLE_CLOUD_SQL || 'true' }}
      run: |
        terraform apply -auto-approve tfplan
    
    - name: üìä Get Service URLs
      if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
      working-directory: apiMS/microservices/terraform
      run: |
        echo "üîó URLs de Servicios:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Auth Service: $(terraform output -raw auth_service_url)" >> $GITHUB_STEP_SUMMARY
        echo "Product Service: $(terraform output -raw product_service_url)" >> $GITHUB_STEP_SUMMARY
        echo "Order Service: $(terraform output -raw order_service_url)" >> $GITHUB_STEP_SUMMARY
        echo "Logistics Service: $(terraform output -raw logistics_service_url)" >> $GITHUB_STEP_SUMMARY
        echo "Notifications Service: $(terraform output -raw notifications_service_url)" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Health Check
  # ============================================================================
  health-check:
    name: Health Check Services
    needs: deploy
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout c√≥digo
      uses: actions/checkout@v4
    
    - name: üîê Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
    
    - name: üê≥ Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
    
    - name: üì¶ Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.6.0"
    
    - name: üîß Terraform Init
      working-directory: apiMS/microservices/terraform
      run: terraform init
    
    - name: üè• Health Check Services
      working-directory: apiMS/microservices/terraform
      run: |
        AUTH_URL=$(terraform output -raw auth_service_url)
        PRODUCT_URL=$(terraform output -raw product_service_url)
        ORDER_URL=$(terraform output -raw order_service_url)
        LOGISTICS_URL=$(terraform output -raw logistics_service_url)
        NOTIFICATIONS_URL=$(terraform output -raw notifications_service_url)
        
        echo "üîç Verificando salud de servicios..."
        echo ""
        
        # Funci√≥n para verificar servicio con retry
        check_service() {
          local name=$1
          local url=$2
          local max_attempts=3
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if curl -f -s --max-time 10 "$url/health" > /dev/null 2>&1; then
              echo "‚úÖ $name OK"
              return 0
            else
              if [ $attempt -lt $max_attempts ]; then
                echo "   ‚è≥ Intento $attempt/$max_attempts fall√≥, reintentando en 5 segundos..."
                sleep 5
              fi
              attempt=$((attempt + 1))
            fi
          done
          
          echo "‚ùå $name FAILED despu√©s de $max_attempts intentos"
          return 1
        }
        
        check_service "Auth Service" "$AUTH_URL"
        check_service "Product Service" "$PRODUCT_URL"
        check_service "Order Service" "$ORDER_URL"
        check_service "Logistics Service" "$LOGISTICS_URL"
        check_service "Notifications Service" "$NOTIFICATIONS_URL"
        
        echo ""
        echo "üìä Resumen de Health Checks completado"

